
float4x4 pWorldViewProj : WorldViewProj;
float4x4 pWorldViewInv : WorldViewInv;
float4x4 pWorldView : WorldView;

uniform float3 lightPos : LightPos;
uniform float phongExp : PhongExp = 50;
uniform bool doISG : DoISG;
uniform float invSceneScale : InvSceneScale;
uniform bool doReflections : DoReflections;
uniform bool isModel : IsModel;
uniform bool isWall  : IsWall;

uniform float glossiness : Glossiness;

sampler2D pWorldPosMap : WorldPosMap;
sampler2D pNormalMap : NormalMap;
sampler2D pReflectionMap : ReflectionMap;
sampler2D pDiffuseTex : DiffuseTex;

////////////////////////////////////////////////////////////////////////////////

struct Pixel
{
  float3 worldPos : COLOR0;
  float3 normal   : COLOR1;
};

struct Vertex
{
  float3 position : POSITION;
  float3 normal   : NORMAL;
  float3 texcoord : TEXCOORD;
};

struct Fragment
{
  float4 position    : POSITION;
  float3 normal      : TEXCOORD0;
  float3 worldPos    : TEXCOORD1;
  float4 hPosition   : TEXCOORD2;
  float2 texcoord    : TEXCOORD3;
  float3 eyePos      : TEXCOORD4;
  float3 lightVec    : TEXCOORD5;
  float3 worldNormal : TEXCOORD6;
};

////////////////////////////////////////////////////////////////////////////////

Fragment display_vp( Vertex v )
{
  Fragment f;

  f.position   = mul(pWorldViewProj, float4( v.position, 1 ));
  f.normal     = mul(pWorldViewInv, float4(v.normal,0));
  f.worldPos   = v.position; // * invViewMatrix
  f.hPosition  = f.position;
  f.texcoord   = v.texcoord.xy;
  
  f.eyePos     = mul(pWorldView, float4(v.position, 1)).xyz;
  f.lightVec   = mul(pWorldView, float4(lightPos - f.worldPos,0)).xyz;
  f.worldNormal = v.normal;

  return f;
}

Pixel worldposnormal_fp(Fragment f) : COLOR
{
  Pixel p;
  p.worldPos = f.worldPos;
  p.normal   = f.worldNormal;
  return p;
}

////////////////////////////////////////////////////////////////////////////////

float2 getNormalizedUV(float4 uv_in)
{
  float2 uv_out = (uv_in.xy/uv_in.w)*.5 + .5;

  return uv_out;
}

float3 getColor(float3 p, float2 uv)
{
  float3 color;
  color = tex2D(pDiffuseTex, uv).xyz;

  return color;
}

float2 ImportanceSample_Warp(float x, float y, float2 stepUV)
{
  const float pi = 3.14159;
  float a = x * stepUV.x;
  float b = y * stepUV.y;
  float r;
  float phi;
  if (a > -b) {
    if (a > b) {
      r = a;
      phi = (pi/4.0) *(b/a);
    }
    else {
      r = b;
      phi = (pi/4.0) *(2 - a/b);
    }
  }
  else {
    if (a < b) {
      r = -a;
      phi = (pi/4.0) *(4 + b/a);
    }
    else {
      r = -b;
      if (b != 0)
        phi = (pi/4.0) *(6 - a/b);
      else
        phi = 0;
    }
  }
  return float2(r*cos(phi),r*sin(phi));
}

float2 ImportanceSample_Regular(float x, float y, float2 stepUV)
{
  return float2(x,y)*stepUV;
}

////////////////////////////////////////////////////////////////////////////////

#define PCF_FILTER_STEP_COUNT 7

float PCFRangeFunction(float3 p0, float3 p1, float3 n0, float3 n1)
{
  const float inv_sigma = 1.f/1e-2f;
  
  float l = length(p0-p1)*invSceneScale;
  float n = 1-dot(n0, n1);

  return exp( -(l*l+n*n)*inv_sigma );
}

float PCFSpatialFunction(float2 offset)
{
  const float inv_sigma = 1.f/0.1f;

  float l = length(offset);
  return exp(-l*l*inv_sigma);
}

float3 BilateralPCFFilter(float2 uv, float2 radius, float3 p0, float3 normal0)
{
  float3 sum = float3(0);
  float weight = 0;
  float2 stepUV = radius / PCF_FILTER_STEP_COUNT;
  for(float y = -PCF_FILTER_STEP_COUNT; y <= PCF_FILTER_STEP_COUNT; ++y) {
    for(float x = -PCF_FILTER_STEP_COUNT; x <= PCF_FILTER_STEP_COUNT; ++x) {
      float2 offset = ImportanceSample_Warp(x,y,stepUV);

      float3 pos = tex2D(pWorldPosMap, uv+offset).xyz;
      if(!isnan(pos.x)) {
        float3 normal = tex2D(pNormalMap, uv+offset).xyz;
        float r = PCFRangeFunction(p0, pos, normal0, normal);
        float s = PCFSpatialFunction(offset);
        float w = r*s;

        sum += tex2D(pReflectionMap, uv+offset).xyz * w;
        weight += w;
      }
    }
  }
  return sum / weight;
}

////////////////////////////////////////////////////////////////////////////////

float RadiusSearchRangeFunction(float3 p0, float3 p1, float3 n0, float3 n1, float distance)
{
  if(distance > 1e15f)
    return 0;

  const float inv_sigma = 1.f/.0005;
  
  float l = length(p0-p1)*invSceneScale;
  float n = 1-dot(n0, n1);
  return exp(-(l*l+n*n)*inv_sigma);
}

#define RADIUS_SEARCH_STEP_COUNT 6

void ISGRadiusSearch(out float average_distance, float2 uv, float2 search_radius, float3 p0, float3 normal0, out int num_reflectors)
{
  float distance_sum = 0;
  float weight_sum = 0;
  num_reflectors = 0;

  float2 stepUV = search_radius / RADIUS_SEARCH_STEP_COUNT;
  for(float y = -RADIUS_SEARCH_STEP_COUNT; y <= RADIUS_SEARCH_STEP_COUNT; ++y) {
    for(float x = -RADIUS_SEARCH_STEP_COUNT; x <= RADIUS_SEARCH_STEP_COUNT; ++x) {
      float2 offset = ImportanceSample_Warp(x,y,stepUV);
      float distance = tex2D(pReflectionMap, uv+offset).w;
      if(distance != -1) {
        float3 pos = tex2D(pWorldPosMap, uv+offset).xyz;
        if(!isnan(pos.x)) {
          float3 normal = tex2D(pNormalMap, uv+offset).xyz;
          float weight = RadiusSearchRangeFunction(p0, pos, normal0, normal, distance);
          
          distance_sum += distance * weight;
          weight_sum   += weight;
          num_reflectors++;
        }
      }
    }
  }

  average_distance = distance_sum / (weight_sum+.00001);
}

float3 ISGFilter(float2 uv, float3 p0, float eyeZ, float cosTheta)
{
  float average_distance;
  float gloss = isModel ? glossiness : glossiness * .5f;
  float3 normal0 = tex2D(pNormalMap, uv).xyz;
  int num_reflectors;
  ISGRadiusSearch(average_distance, uv, gloss, p0, normal0, num_reflectors);

  if(num_reflectors == 0)
    return tex2D(pReflectionMap, uv).xyz;

  float gloss_radius = gloss * average_distance / (eyeZ + average_distance);

  return BilateralPCFFilter(uv, max(cosTheta,.05) * gloss_radius, p0, normal0);
}

////////////////////////////////////////////////////////////////////////////////

float4 glossy_reflections_fp(Fragment f) : COLOR
{
  float3 V = normalize(f.eyePos);
  float3 L = normalize(f.lightVec);
  float3 Ka = float3(.05f);
  float3 N = normalize(f.normal);
  float ndl = clamp(dot(N, L),0.f,1.f);

  // check reflection map here
  float3 refl=float3(0);
  float2 uv = getNormalizedUV(f.hPosition);
  
  if(!isWall && doReflections) {
    if(doISG)
      refl = ISGFilter(uv, f.worldPos, -f.eyePos.z, abs(dot(V,N)));
    else
      refl = tex2D(pReflectionMap, uv).xyz;
  }

  // a little fresnel
  float R0 = isModel ? .9 : .3;
  float cosTheta = abs(dot(V,N));
  float tmp = 1-cosTheta;
  tmp = tmp*tmp;
  tmp = tmp*tmp;
  tmp = tmp*(1-cosTheta);
  float fresnel = R0 + (1-R0)*tmp;
  float3 result = fresnel*refl;

  if(isModel)
    return float4(result * getColor(f.worldPos, f.texcoord),1);

  // ambient and diffuse
  result += getColor(f.worldPos, f.texcoord) * (Ka + ndl);

  // phong specular
  float3 R=reflect(V, N);
  float  spec = pow(clamp(dot(L,R),0.f,1.f), phongExp);
  result += float3(spec)*.5f;

  return float4(result, 1);
}

////////////////////////////////////////////////////////////////////////////////

technique WorldPosNormal
{
  pass p0
  {
    VertexProgram = compile CG_VERTEX_PROFILE display_vp();
    FragmentProgram = compile CG_FRAGMENT_PROFILE worldposnormal_fp();
  }
}

technique GlossyReflections
{
  pass p0
  {
    VertexProgram = compile CG_VERTEX_PROFILE display_vp();
    FragmentProgram = compile CG_FRAGMENT_PROFILE glossy_reflections_fp();
  }
}
